<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Selection sort and Insertion Sort Sorted Lists and Binary Search 1 2 3 4 5 6 7  def search(lst: list, item: Any) -> int: &#34;&#34;&#34;Return whether item appears in this list.&#34;&#34;&#34; for element in lst: if element = item: return True return False    This function has a worst-case running time of $\Theta(n)$, where $n$ is the length of lst A more &ldquo;smart&rdquo; way is to compare the searched element with the middle number of an arranged list and decide to continue the search on the left, right, or stop (if found in the middle one)  Binary search - &ldquo;binary&rdquo; refers to the fact that at every comparison, the range of elements to check is hailed    Implementing binary search (iteratively)  Need to keep track of the current search range, use variables: b and e, which divide search in 3 parts  lst[0:b] - items that are less than the item being searched for lst[b:e] - the current search range: lst[e:len(lst)] only the items that are greater than the item been searched for       First, calculate the midpoint m of the current range Then compare lst[m] against item Stop the lop with lst[b:e] is empty (that is when b>=e)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  def binary_search(lst: list, item: Any) -> bool: &#34;&#34;&#34;Return whether tiem is in lst using the binary search algorithem Preconditions: - is_sorted(lst) &#34;&#34;&#34; b, e = 0, len(lst) while b < e: # Loop invariants assert all(lst[i] < item for i in range (0, b)) assert all(lst[i] > item for i in range (e, len(lst))) m = (b + e) // 2 if item == lst[m]: return True elif item < lst[m]: e = m else: # item > list[m] b = m + 1 # If the loop ends wihtout finding the item return False   Running time  e - b is initially equals to $n$, the length of the input The loop stops when e - b <= 0 Each iteration, e - b decrease by at least a factor of 2   Putting it together get $RT < 1 + \log_2n$ which is $\Theta(\log n)$, much better than linear search $\Theta(n)$  Selection Sort   Given a collection of unsorted elements, repeatedly extract the smallest element form the collection, building up a sorted list from this"><title>CSC111: 10_Selection and Insertion</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://mel10c.github.io/mel.zhu//icon.png><link href=https://mel10c.github.io/mel.zhu/styles.9a8661985b360a1d97e0e538e164abef.min.css rel=stylesheet><link href=https://mel10c.github.io/mel.zhu/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://mel10c.github.io/mel.zhu/js/darkmode.905e4d2da56a9111aff695a0a4b69900.min.js></script>
<script src=https://mel10c.github.io/mel.zhu/js/util.6f22941e242efae60fd84e7c32e874fa.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script async src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script async src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script async src=https://mel10c.github.io/mel.zhu/js/popover.f03552ccb84d99ca615d1cfb9abde59e.min.js></script>
<script defer src=https://mel10c.github.io/mel.zhu/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://mel10c.github.io/mel.zhu/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://mel10c.github.io/mel.zhu/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://mel10c.github.io/mel.zhu/",fetchData=Promise.all([fetch("https://mel10c.github.io/mel.zhu/indices/linkIndex.5702adc893417d7a266d9ed2e8ebdba1.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://mel10c.github.io/mel.zhu/indices/contentIndex.29e8901604d17bba5377fc5ce2a7f2c6.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://mel10c.github.io/mel.zhu",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://mel10c.github.io/mel.zhu",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/mel10c.github.io\/mel.zhu\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://mel10c.github.io/mel.zhu/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://mel10c.github.io/mel.zhu/>MEL.ZHU</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>CSC111: 10_Selection and Insertion</h1><p class=meta>Last updated
Unknown</p><ul class=tags><li><a href=https://mel10c.github.io/mel.zhu/tags/note/>Note</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#sorted-lists-and-binary-search>Sorted Lists and Binary Search</a><ol><li><a href=#implementing-binary-search-iteratively>Implementing binary search (iteratively)</a></li><li><a href=#running-time>Running time</a></li></ol></li><li><a href=#selection-sort>Selection Sort</a><ol><li><a href=#running-time-analysis>Running time analysis</a></li></ol></li><li><a href=#insertion-sort>Insertion Sort</a><ol><li><a href=#running-time-analysis-1>Running-time analysis</a></li></ol></li><li><a href=#selection-sort-vs-insertion-sort>Selection sort vs. Insertion sort</a></li></ol></nav></details></aside><a href=#selection-sort-and-insertion-sort><h1 id=selection-sort-and-insertion-sort><span class=hanchor arialabel=Anchor># </span>Selection sort and Insertion Sort</h1></a><a href=#sorted-lists-and-binary-search><h2 id=sorted-lists-and-binary-search><span class=hanchor arialabel=Anchor># </span>Sorted Lists and Binary Search</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>search</span><span class=p>(</span><span class=n>lst</span><span class=p>:</span> <span class=nb>list</span><span class=p>,</span> <span class=n>item</span><span class=p>:</span> <span class=n>Any</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Return whether item appears in this list.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>element</span> <span class=ow>in</span> <span class=n>lst</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>element</span> <span class=o>=</span> <span class=n>item</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>False</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>This function has a worst-case running time of $\Theta(n)$, where $n$ is the length of <code>lst</code></li><li>A more &ldquo;smart&rdquo; way is to compare the searched element with the middle number of an arranged list and decide to continue the search on the left, right, or stop (if found in the middle one)<ul><li><u>Binary search</u> - &ldquo;binary&rdquo; refers to the fact that at every comparison, the range of elements to check is hailed</li></ul></li></ul><a href=#implementing-binary-search-iteratively><h3 id=implementing-binary-search-iteratively><span class=hanchor arialabel=Anchor># </span>Implementing binary search (iteratively)</h3></a><ul><li>Need to keep track of the <em>current search range</em>, use variables: <code>b</code> and <code>e</code>, which divide search in 3 parts<ul><li><code>lst[0:b]</code> - items that are <em>less than</em> the item being searched for</li><li><code>lst[b:e]</code> - the current search range:</li><li><code>lst[e:len(lst)]</code> only the items that are <em>greater than</em> the item been searched for</li><li><img src=https://tva1.sinaimg.cn/large/008eGmZEly1gp9gp8srodj30q307zt8o.jpg alt=range style=zoom:20%></li></ul></li></ul><ol><li>First, calculate the midpoint <code>m</code> of the current range</li><li>Then compare <code>lst[m]</code> against <code>item</code></li><li>Stop the lop with <code>lst[b:e]</code> is empty (that is when <code>b>=e</code>)</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_search</span><span class=p>(</span><span class=n>lst</span><span class=p>:</span> <span class=nb>list</span><span class=p>,</span> <span class=n>item</span><span class=p>:</span> <span class=n>Any</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Return whether tiem is in lst using the binary search algorithem 
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Preconditions:
</span></span></span><span class=line><span class=cl><span class=s2>    	- is_sorted(lst)
</span></span></span><span class=line><span class=cl><span class=s2>     &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=p>,</span> <span class=n>e</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>lst</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>b</span> <span class=o>&lt;</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Loop invariants</span>
</span></span><span class=line><span class=cl>        <span class=k>assert</span> <span class=nb>all</span><span class=p>(</span><span class=n>lst</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>item</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>assert</span> <span class=nb>all</span><span class=p>(</span><span class=n>lst</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>item</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span> <span class=p>(</span><span class=n>e</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>lst</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=n>b</span> <span class=o>+</span> <span class=n>e</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>item</span> <span class=o>==</span> <span class=n>lst</span><span class=p>[</span><span class=n>m</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>item</span> <span class=o>&lt;</span> <span class=n>lst</span><span class=p>[</span><span class=n>m</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>e</span> <span class=o>=</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>  <span class=c1># item &gt; list[m]</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span> <span class=o>=</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=c1># If the loop ends wihtout finding the item</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>False</span>
</span></span></code></pre></td></tr></table></div></div><a href=#running-time><h3 id=running-time><span class=hanchor arialabel=Anchor># </span>Running time</h3></a><ol><li><code>e - b</code> is initially equals to $n$, the length of the input</li><li>The loop stops when <code>e - b &lt;= 0</code></li><li>Each iteration, <code>e - b</code> decrease by at least a factor of 2</li></ol><ul><li>Putting it together get $RT &lt; 1 + \log_2n$ which is $\Theta(\log n)$, much better than linear search $\Theta(n)$</li></ul><a href=#selection-sort><h2 id=selection-sort><span class=hanchor arialabel=Anchor># </span>Selection Sort</h2></a><ul><li><p>Given a collection of <strong>unsorted</strong> elements, repeatedly extract the smallest element form the collection, building up a sorted list from this</p></li><li><p><u>In-place sort</u> - sorts a list by mutating its input list, without using any additional list objects</p><p><img src=https://tva1.sinaimg.cn/large/008eGmZEly1gp9h3yb96yj30890opdgf.jpg alt=sort style=zoom:30%> (Represent the boundary <code>i</code> as a <em>loop invariant</em>)</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>selection_sort</span><span class=p>(</span><span class=n>lst</span><span class=p>:</span> <span class=nb>list</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Sort the given list using the selection sort algorithm
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Note that this is a *mutating* function
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; lst = [3, 7, 2, 5]
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; slection_sort(lst)
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; lst
</span></span></span><span class=line><span class=cl><span class=s2>    [2, 3, 5, 7]
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>lst</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Loop invariants</span>
</span></span><span class=line><span class=cl>        <span class=k>assert</span> <span class=n>is_sorted</span><span class=p>(</span><span class=n>lst</span><span class=p>[:</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>assert</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=nb>all</span><span class=p>(</span><span class=n>lst</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>lst</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># Find the index of the smallest item in lst[i:] and swap that item</span>
</span></span><span class=line><span class=cl>        <span class=c1># with the item at index i</span>
</span></span><span class=line><span class=cl>        <span class=n>index_of_smallest</span> <span class=o>=</span> <span class=n>_min_index</span><span class=p>(</span><span class=n>lst</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>lst</span><span class=p>[</span><span class=n>index_of_smallest</span><span class=p>],</span> <span class=n>lst</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>lst</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>lst</span><span class=p>[</span><span class=n>index_of_smallest</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>_min_index</span><span class=p>(</span><span class=n>lst</span><span class=p>:</span> <span class=nb>list</span><span class=p>,</span> <span class=n>i</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Return the index of the smallest item in lst[i:]
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    In the case of ties, return the smaller index
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Preconditions;
</span></span></span><span class=line><span class=cl><span class=s2>    	- 0 &lt;= i &lt;= len(lst) - 1
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>index_of_smallest_so_far</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>lst</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>lst</span><span class=p>[</span><span class=n>index_of_smallest_so_far</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>index_of_smallest_so_far</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>index_of_smallest_so_far</span>
</span></span></code></pre></td></tr></table></div></div><a href=#running-time-analysis><h3 id=running-time-analysis><span class=hanchor arialabel=Anchor># </span>Running time analysis</h3></a><ol><li>Let $n$ be the length of input list <code>lst</code></li><li>The helper function <code>_min_index</code><ul><li>The loop iterates $n-i-1$ times, for $j = i+1, &mldr;, n-1$, body takes constant time</li><li>Total running time is $\Theta(n-i)$</li></ul></li><li>The function <code>selction_sort</code>, calls the helper function, where $i$ is the value of the for loop variable, plus one more step. And it iterates once for each $i$ between $0$ and $n-1$, inclusive.</li></ol><ul><li>This gives a total running time of
$$
\begin{align*}
\sum_{i=0} ^{n-1} n-i+1 &= n(n+1) - \sum_{i=0}^{n-1}i \\ &= n(n+1) - \frac{n(n-1)}{2} \\ &= \frac{n(n+3)}{2}
\end{align*}
$$
Therefore, the running time of <code>selection_sort</code> is $\Theta(n^2)$</li></ul><a href=#insertion-sort><h2 id=insertion-sort><span class=hanchor arialabel=Anchor># </span>Insertion Sort</h2></a><ul><li><p><u>Insertion sort</u> - it always take the next item in the last and insert it into he sorted part by moving it to the correct location, use variable <code>i</code> to keep track of the sorted boundaries
<img src=https://tva1.sinaimg.cn/large/008eGmZEly1gpbidpfjufj309x0sgaax.jpg alt=insertion style=zoom:30%></p><ul><li>Insertion has a similar loop structure to selection sort, it shares the key &ldquo;sorted/unsorted parts&rdquo; loop invariants as well</li><li>Use a <code>_insert</code> helper function to perform the insertion programs</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>_insert</span><span class=p>(</span><span class=n>lst</span><span class=p>:</span> <span class=nb>list</span><span class=p>,</span> <span class=n>i</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Move lst[i] so that lst[:i + 1] is sorted
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Preconditions: 
</span></span></span><span class=line><span class=cl><span class=s2>    	- 0 &lt;= i &lt;= len(lst)
</span></span></span><span class=line><span class=cl><span class=s2>    	- is_sorted(lst[:i])
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; lst = [7, 3, 5, 2]
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; _insert(lst, 1)
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt; lst  # lst[:2] is not sorted yet
</span></span></span><span class=line><span class=cl><span class=s2>    [3, 7, 5, 2]
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># Version 1, using an early return</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>rnage</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>  <span class=c1># this goes from i down to 1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Swap lst[j - 1] and lst[j]</span>
</span></span><span class=line><span class=cl>            <span class=n>lst</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>],</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Version 2, using a compund loop condition</span>
</span></span><span class=line><span class=cl>    <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=ow>not</span> <span class=p>(</span><span class=n>j</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Swap lst[j - 1] and lst[j]</span>
</span></span><span class=line><span class=cl>        <span class=n>lst</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>],</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>lst</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>insertion_sort</span><span class=p>(</span><span class=n>lst</span><span class=p>:</span> <span class=nb>list</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Sort the given lst using the selection sort algorithm.
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Note that this is a *mutating* function
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>lst</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>assert</span> <span class=n>is_sorted</span><span class=p>(</span><span class=n>lst</span><span class=p>[:</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>_insert</span><span class=p>(</span><span class=n>lst</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><a href=#running-time-analysis-1><h3 id=running-time-analysis-1><span class=hanchor arialabel=Anchor># </span>Running-time analysis</h3></a><ul><li>Need to analysis the <em>worst-case</em> running for the helper <code>_insert</code> running time<ul><li><strong>Upper bound</strong> - Let $n \in \N$, and let <code>lst</code> be an arbitrary list of length, Let $i \in \N$ , assume $i &lt;n$<ul><li>The loop would run <em>at most</em> $i$ times (for $j=i, i-1, &mldr;, 1$), constant time each iteration</li><li>This function runs <em>at most</em> $i$ steps. ($\Theta(i)$)</li></ul></li><li><strong>Lower bound</strong> - consider <code>lst</code> where <code>lst[i]</code> is less than all items in <code>lst[:i]</code><ul><li>In this case <code>lst[j-1] &lt;= lst[j]</code> will always be False, so lop will stop when <code>j == 0</code>, which takes $i$ iterations. So the running time is also $\Theta(i)$</li></ul></li><li>Therefore the <em>worst-case</em> running time for <code>_insert</code>is $\Theta(i)$</li></ul></li><li>Running time for <code>insertion_sort</code> also have a spread of running times, also need <em>worst-case</em><ul><li><strong>Upper bound</strong> - Let $n \in \N$, let <code>lst</code> be an arbitrary list of length $n$,<ul><li>The loop takes $n$ times, for $i = 0, 1, &mldr;, n-1$</li><li>This means the loop body calls the helper <code>_insert</code> at most $i$ steps</li><li>This gives an upper bound of $\sum_{i=0}^{n-1}~ I = \frac{n(n-1)}{2}$ which is $\Theta(n^2)$</li></ul></li><li><strong>Lower bound</strong> - let $n \in \N$, and let <code>lst</code> be the list $[n-1, n-2, &mldr;, 1, 0]$.<ul><li>This input is an extension of the input family for <code>_insert</code>: for all $i \in \N$, this input has <code>lst[i]</code> less than every element in <code>lst[:i]</code>. As we described above, this causes each call to <code>_insert</code> to take $i$ steps.</li><li>This gives a total running time for this input family of $\frac{n(n-1)}{2}$, which is $\Theta(n^2)$, matching the upper bound on the worst-case running time.</li></ul></li><li>Therefore the <em>worst-case</em> running time for <code>insertion_sort</code> is $\Theta(n^2)$</li></ul></li></ul><a href=#selection-sort-vs-insertion-sort><h2 id=selection-sort-vs-insertion-sort><span class=hanchor arialabel=Anchor># </span>Selection sort vs. Insertion sort</h2></a><ul><li>Both selection sort and insertion sort are <em>iterative</em> sorting algorithms, meaning they are implemented using a loop.</li><li>The action inside each loop iteration as being divided into two phases:<ol><li>Selecting which remaining item to add to the sorted part</li><li>Adding that item to the sorted part.</li></ol></li><li>Running time is similar, but it is actually, is very different<ul><li>Selection sort <strong>always</strong> takes $\Theta(n^2)$</li><li>Insertion sort has a <strong>worst-case</strong> running time of $\Theta(n^2)$, but it could takes short time</li></ul></li><li>Insertion sort is preferable because of its potential to be more efficient on many different input lists</li></ul></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://mel10c.github.io/mel.zhu/js/graph.2d9e48dbe7ea47c0ef1c58296ce14448.js></script></div></div><div id=contact_buttons><footer><p>Made by Melaney Zhu using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://mel10c.github.io/mel.zhu/>Home</a></li><li><a href=https://www.instagram.com/melaney_dxl/>Instagram</a></li><li><a href=https://github.com/mel10c>GitHub</a></li><li><a href=https://linkedin.com/in/melzyy>LinkedIn</a></li><li><a href=https://github.com/mel10c/mel.zhu/blob/hugo/content/documents/Resume.pdf>Resume</a></li></ul></footer></div></div></body></html>